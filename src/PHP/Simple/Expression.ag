MODULE {PHP.Simple.Expression}
{}
{
import qualified Data.Set as S
}

PRAGMA genlinepragmas

DATA Expression 
    | BinOp     left: Expression  op: String  right: Expression
    | UnaryOp   op: String exp: Expression
    | Const     value: String
    | Var       value: String
    | Func      name: String  args: ExpressionList

TYPE ExpressionList = [ Expression ]

SET Expressions = ExpressionList Expression
    
DERIVING Expression: Eq, Show


--Free variables
ATTR Expressions [||vars USE {`S.union`} {S.empty}: {S.Set String}]

SEM Expression    
    | Var       lhs.vars = S.singleton @value

--Functions
ATTR Expressions [||funcs USE {`S.union`} {S.empty}: {S.Set String}]

SEM Expression
    | Func      +funcs = S.insert @name

--Copy self
ATTR Expressions [||                 
                   me : SELF
                   meSmall : SELF
                 ]

{

expFreeVars::Expression -> S.Set String
expFreeVars exp = vars_Syn_Expression $ wrap_Expression (sem_Expression exp) Inh_Expression

expFuncs::Expression -> S.Set String
expFuncs exp = funcs_Syn_Expression $ wrap_Expression (sem_Expression exp) Inh_Expression
}
