MODULE {PHP.Simple.SimpleAst}
{}

{
import Data.List
import qualified Data.Set as S
import qualified Data.IntMap as IM
import qualified Data.Map as M
import qualified MF.Program as P
import Debug.Trace
}

PRAGMA genlinepragmas

--Expressions
DATA Expression 
    | Assign    var:String exp:Expression  op:String
    | BinOp     left: Expression  op: String  right: Expression
    | UnaryOp   op: String exp: Expression
    
    | Const     value: String
    | Var       value: String
    
    | Func      name: String  args: ExpressionList
    | TernaryIf cond:Expression thn:Expression els:Expression
DERIVING Expression: Eq, Show

TYPE ExpressionList = [ Expression ]

SET Expressions = Expression ExpressionList

--Statements
DATA Statement    
    | Expr      exp:Expression  
    
    | If        exp:Expression thn:StatementList els:StatementList
    | While     exp:Expression block:StatementList
    | For       start:Expression stop:Expression inc:Expression block:StatementList

    | Break
    | Continue

    | FuncDef   name:String args:{[String]} block:StatementList
    | Return    exp:Expression
DERIVING Statement: Eq, Show

TYPE StatementList = [ Statement ]

SET Statements = StatementList Statement

--Data type to hide the internal functionality of the grammar (instead of complicated wrapper).
DATA Program    
    | Program   stats: StatementList

SET Inner      = Statements Expressions --Only inner part of the program (everything excpet top Program datatype).

SET All        = Inner Program --Entire program

ATTR All [|labels USE {`IM.union`} {IM.empty}: {IM.IntMap P.Statement} --Map of labels
          |entry :Int                       --Entry label to code block
           flow USE {++} {[]}: {[(Int,Int)]} --Accumulated flow graph
          ]    

ATTR Inner [exit   :Int --Holds value where to go when done with a block.            
            cont   :Int --Label where to go for continue
            break  :Int --Label where to go when brak
            inFunc :String --Label in which function we are
            defs: {M.Map String Int} --Function definitions, used for lookup of function call
            rets: {M.Map String [Int]} --List of return statement labels for a certain function, call locations.
           |labelcount:Int --Incrementor for labels
           |]

--Unique labels for all in loc.label
SEM Statement
    | Expr If While Break Continue FuncDef Return For
        loc.label   : UNIQUEREF labelcount 
    | FuncDef
        loc.retLabel: UNIQUEREF labelcount 

SEM ExpressionList
    | Cons --Labels for replacement variables of function call arguments.
        loc.label   : UNIQUEREF labelcount 

SEM Expression    
    | BinOp UnaryOp Var Const Func Assign TernaryIf
        loc.label   : UNIQUEREF labelcount
    | Func --Additional label for the return statement
        loc.labelOut: UNIQUEREF labelcount          
    | TernaryIf
        loc.thenLabel: UNIQUEREF labelcount
        loc.elseLabel: UNIQUEREF labelcount


--Statements

--Statement  

SEM Statement
    | Expr      lhs.entry = @exp.entry --just pass through
                exp.exit  = @lhs.exit

    | While If Return --For these statements, first run the containing expression and then the command itself.
                lhs.entry   = @exp.entry
                exp.exit    = @loc.label

    | While     +labels = IM.insert @loc.label (P.While (P.Val . P.Var $ @exp.myvar))
                +flow   = ([(@loc.label, @lhs.exit) --To exit
                           ,(@loc.label, @block.entry)]++) --Flow to inner block
                block.exit  = @exp.entry --Set inherited attributes for while block
                block.cont  = @exp.entry
                block.break = @lhs.exit

    | For       +labels = IM.insert @loc.label (P.While (P.Val . P.Var $ @stop.myvar))
                +flow   = ([(@loc.label, @lhs.exit)
                           ,(@loc.label, @block.entry)]++)
                
                lhs.entry   = @start.entry --Wire expressions
                start.exit  = @stop.entry
                stop.exit   = @loc.label
                
                block.exit  = @inc.entry 
                block.cont  = @inc.entry
                block.break = @lhs.exit
                
                inc.exit    = @stop.entry

    | If        +labels = IM.insert @loc.label (P.If (P.Val . P.Var $ @exp.myvar))
                +flow   = ([(@loc.label, @thn.entry) --Add flow for then and else block
                           ,(@loc.label, @els.entry)]++)

    | Return    +labels = IM.insert @loc.label (P.Return (P.Val . P.Var $ @exp.myvar))
                    --Return flows to all return labels of calling functions in the program.
                +flow   = ((map (\to -> (@loc.label, to)) (M.findWithDefault [] @lhs.inFunc @lhs.rets))++)

    | FuncDef   +labels = IM.union (IM.fromList [(@loc.label   , P.FuncIn @name @args)
                                                ,(@loc.retLabel, P.Return (P.Val . P.Const $ "Nothing"))])
                +flow   = (((@loc.label, @block.entry) : 
                            map (\to -> (@loc.retLabel, to)) (M.findWithDefault [] @name @lhs.rets)) ++) --Flow form function entry to block
                lhs.entry    = @lhs.exit --FuncDef = no-op (entry=exit)
                block.exit   = @loc.retLabel --A function block has no exit value
                block.inFunc = @name                

    | Break Continue --Just run these statements
                lhs.entry   = @loc.label

    | Break     +labels = IM.insert @loc.label P.Break
    | Continue  +labels = IM.insert @loc.label P.Continue
    
--Wire the statements through a code block
SEM StatementList
    | Nil       lhs.entry   = @lhs.exit --On the end of the block, entry becomes exit.
    | Cons      lhs.entry   = @hd.entry --Wire the head to the rest of the block and make head the first
                hd.exit     = @tl.entry

--Expressions

--Expression
{-Replace functions with variables-}
ATTR Expression [||
                    myvar:{String}  --Variable containing inner expression
                  ]
ATTR ExpressionList [||varlist: {[String]}]   --List of vars generated for expression

SEM Expression    --Labels
    | BinOp UnaryOp Const Func TernaryIf
                loc.expvar  = "$_"++show @loc.label       
    | BinOp Const Func TernaryIf
                lhs.myvar   = @loc.expvar

    | BinOp     +labels     = IM.insert @loc.label (P.Assign @loc.expvar (P.BinOp (P.Var @left.myvar) @op (P.Var @right.myvar)) "")
                +flow       = ((@loc.label, @lhs.exit):) --Flow through

                lhs.entry   = @left.entry --Wire through
                left.exit   = @right.entry
                right.exit  = @loc.label

    | UnaryOp   +labels     = IM.insert @loc.label $ unarySideEffect @exp.myvar @loc.expvar @op
                +flow       = ((@loc.label, @lhs.exit):) --Flow through
                lhs.entry   = @exp.entry
                exp.exit    = @loc.label
                lhs.myvar   = P.var $ unarySideEffect @exp.myvar @loc.expvar @op

    | Var       lhs.entry   = @lhs.exit --Wire through
                lhs.myvar   = @value               

    | Const     +labels     = IM.insert @loc.label (P.Assign @loc.expvar (P.Val .P.Const $ @value) "")
                +flow       = ((@loc.label, @lhs.exit):) --Flow through
                lhs.entry   = @loc.label

    | Assign    +labels     = IM.insert @loc.label (P.Assign @var (P.Val . P.Var $ @exp.myvar) @op)
                +flow       = ((@loc.label, @lhs.exit):) --Flow through
                lhs.entry   = @exp.entry --Wire through
                exp.exit    = @loc.label
                lhs.myvar   = @var --Represented by variable

    | Func      +labels   = IM.union (IM.fromList [( @loc.label   , P.FuncCall @name @args.varlist), 
                                                   ( @loc.labelOut, P.FuncBack @name @loc.expvar)])

                +flow   = ([(@loc.label, M.findWithDefault (-1) @name @lhs.defs) --Call function
                           ,(@loc.labelOut, @lhs.exit) --Back to out flow
                           ,(@loc.label, @loc.labelOut)]++) --Call to Back flow
                
                lhs.entry   = @args.entry --Wire function call through aruments
                args.exit   = @loc.label 
    
    | TernaryIf +labels = IM.union (IM.fromList 
                            [( @loc.label, (P.If (P.Val . P.Var $ @cond.myvar)))
                            ,( @loc.thenLabel, (P.Assign @loc.expvar (P.Val . P.Var $ @thn.myvar) ""))
                            ,( @loc.elseLabel, (P.Assign @loc.expvar (P.Val . P.Var $ @els.myvar) ""))])
                +flow   = ([(@loc.label, @thn.entry) --Add flow for then and else block
                           ,(@loc.label, @els.entry)
                           ,(@loc.thenLabel, @lhs.exit)
                           ,(@loc.elseLabel, @lhs.exit)]++)

                lhs.entry   = @cond.entry
                cond.exit   = @loc.label                
                thn.exit    = @loc.thenLabel
                els.exit    = @loc.elseLabel

--Expression list
SEM ExpressionList --Labels
    | Nil       lhs.varlist = []
                lhs.entry   = @lhs.exit
                
            --Replace list arguments with placeholder variables and corresponding assignments
    | Cons      +varlist    = (@hd.myvar:) --Create list of replacement values
                lhs.entry   = @hd.entry
                hd.exit     = @tl.entry

--Range of influence
ATTR All [||roi USE {`IM.union`} {IM.empty}:{IM.IntMap (S.Set Int)}]

SEM Statement
    | While     +roi = IM.insert @loc.label (S.fromList (IM.keys @block.labels))
    | For       +roi = IM.insert @loc.label (S.fromList (IM.keys @block.labels))
    | If        +roi = IM.insert @loc.label (S.fromList (IM.keys @thn.labels ++ IM.keys @els.labels))
    | FuncDef   +roi = IM.insert @loc.label (S.fromList (IM.keys @block.labels))

--Setup Program
SEM Program
    | Program   stats.defs  = defMap @stats.labels
                stats.rets  = retMap @stats.labels
                stats.exit  = -1
                stats.cont  = -1
                stats.break = -1
                stats.labelcount = 0
                stats.inFunc = "main"          
{
--Convert unary to binary
unarySideEffect::String -> String -> String -> P.Statement
unarySideEffect v vn "++" = P.Assign v (P.Val (P.Const "1")) "+"
unarySideEffect v vn "--" = P.Assign v (P.Val (P.Const "1")) "-"
unarySideEffect v vn op   = P.Assign vn (P.UnaryOp (P.Var v) op) ""


defMap :: IM.IntMap P.Statement -> M.Map String Int
defMap = foldr f M.empty . IM.toList
    where f (i, P.FuncIn n as) m = M.insert n i m
          f _                  m = m

retMap :: IM.IntMap P.Statement -> M.Map String [Int]
retMap = foldr f M.empty . IM.toList
    where f (i, P.FuncBack n as) m = M.insertWith (++) n [i] m
          f _                    m = m

nextUnique :: Int -> (Int, Int)
nextUnique u = (u+1, u)

inh::Inh_Program
inh = Inh_Program
      {labels_Inh_Program = IM.empty
      }

labels::Program -> IM.IntMap P.Statement
labels slist = labels_Syn_Program $ wrap_Program (sem_Program slist) inh

filterFlow::[(Int,Int)] -> [(Int,Int)]
filterFlow = filter (\(i,t) -> i /= -1 && t /= -1)

flow::Program -> [(Int,Int)]
flow slist = filterFlow $ flow_Syn_Program $ wrap_Program (sem_Program slist) inh

entry::Program -> Int
entry slist = entry_Syn_Program $ wrap_Program (sem_Program slist) inh

roi::Program -> IM.IntMap (S.Set Int)
roi slist = roi_Syn_Program $ wrap_Program (sem_Program slist) inh

program::Program -> P.Program
program p = let res = wrap_Program (sem_Program p) inh
            in P.Program
                {P.blocks = labels_Syn_Program res
                ,P.flow   = filterFlow $ flow_Syn_Program res
                ,P.startLabel  = entry_Syn_Program res
                ,P.finalLabels   = []
                ,P.rangeOfInfluence = roi_Syn_Program res}

}
