MODULE {PHP.Simple.Statement}
{}
{
import qualified Data.Set as S
import qualified Data.IntMap as IM
}

INCLUDE "Expression.ag"

PRAGMA genlinepragmas

DATA Statement
    | Assign    var:String exp:Expression
    | Expr      exp:Expression  
    
    | If        exp:Expression thn:StatementList els:StatementList
    | While     exp:Expression block:StatementList
    | Break
    | Continue

    | FuncDef   name:String args:{[String]} block:StatementList
    | Return    exp:Expression

DERIVING Statement: Eq, Show

TYPE StatementList = [ Statement ]

SET Statements = StatementList Statement

    
--Free variables
ATTR Statements [|| vars USE {`S.union`} {S.empty}: {S.Set String}]

SEM Statement
    | Assign    +vars    = S.insert @var    
    | FuncDef   +vars    = S.union (S.fromList @args)

--Shrinked statements
ATTR Statements [||me :SELF
                   meSmall :SELF                   
                ]

SEM StatementList
    | Cons  lhs.meSmall = []


--Lines
ATTR Statements [|lines:Int|line: Int] --Accumulator for line numbers

SEM Statement
    | Assign Expr If While Break Continue FuncDef Return
        loc.line : UNIQUEREF lines    
        lhs.line = @loc.line

--Labels
ATTR Statements [|| labels USE {`IM.union`} {IM.empty}: {IM.IntMap Statement}]

SEM Statement
    | Assign Expr If While Break Continue FuncDef Return
        +labels = IM.insert @loc.line @meSmall


--Flow

--Denotes entrance of a block
ATTR Statements [outLabel : Int --Holds value where to go when done.
               ||flow USE {++} {[]}: {[(Int,Int)]}
                ]

SEM StatementList
    | Nil  lhs.line    = 0
    | Cons lhs.line    = @hd.line
           hd.outLabel = if @tl.line == 0 then @lhs.outLabel else @tl.line           

SEM Statement
    | Assign Expr While
            +flow          = ((@loc.line, @lhs.outLabel):)
    | If    +flow          = ([(@loc.line, @thn.line),(@loc.line, @els.line)]++)
    | While block.outLabel = @loc.line
            +flow          = ((@loc.line, @block.line):)

{

nextUnique :: Int -> (Int, Int)
nextUnique u = (u+1, u)

usedVars::StatementList -> S.Set String
usedVars slist = vars_Syn_StatementList $ wrap_StatementList (sem_StatementList slist) inh
    where inh = Inh_StatementList
                { lines_Inh_StatementList = 0                
                , outLabel_Inh_StatementList = 9999}

labels::StatementList -> IM.IntMap Statement
labels slist = labels_Syn_StatementList $ wrap_StatementList (sem_StatementList slist) inh
    where inh = Inh_StatementList
                { lines_Inh_StatementList = 0
                , outLabel_Inh_StatementList = 9999}

flow::StatementList -> [(Int,Int)]
flow slist = flow_Syn_StatementList $ wrap_StatementList (sem_StatementList slist) inh
    where inh = Inh_StatementList
                { lines_Inh_StatementList = 0
                , outLabel_Inh_StatementList = 9999}
}
